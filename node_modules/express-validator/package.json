{
  "name": "express-validator",
  "description": "Express middleware for the validator module.",
  "author": {
    "name": "Christoph Tavan",
    "email": "dev@tavan.de"
  },
  "contributors": [
    {
      "name": "Chris O'Hara",
      "email": "cohara87@gmail.com"
    },
    {
      "name": "@orfaust"
    },
    {
      "name": "@zero21xxx"
    },
    {
      "name": "Roman Kalyakin",
      "email": "roman@kalyakin.com"
    },
    {
      "name": "Rusty Bailey",
      "email": "rustylbailey@gmail.com"
    }
  ],
  "version": "2.20.10",
  "homepage": "https://github.com/ctavan/express-validator",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "git://github.com/ctavan/express-validator.git"
  },
  "main": "./index.js",
  "scripts": {
    "test": "mocha",
    "jshint": "jshint ./test ./lib",
    "jscs": "jscs ./test ./lib",
    "travis-build": "npm test && npm run jshint && npm run jscs",
    "changelog": "github-changes -o ctavan -r express-validator -a -m YYYY/MM/DD --no-merges"
  },
  "engines": {
    "node": ">= 0.10"
  },
  "dependencies": {
    "bluebird": "3.4.x",
    "lodash": "4.16.x",
    "validator": "5.7.x"
  },
  "devDependencies": {
    "body-parser": "1.12.3",
    "chai": "2.3.0",
    "express": "4.12.3",
    "github-changes": "1.0.2",
    "jscs": "1.13.1",
    "jshint": "2.7.0",
    "mocha": "2.2.4",
    "supertest": "0.15.0"
  },
  "keywords": [
    "express",
    "validator",
    "validation",
    "validate",
    "sanitize",
    "sanitization",
    "xss"
  ],
  "readme": "# express-validator\r\n\r\n[![npm version](https://badge.fury.io/js/express-validator.svg)](https://badge.fury.io/js/express-validator) [![Build Status](https://secure.travis-ci.org/ctavan/express-validator.png)](http://travis-ci.org/ctavan/express-validator) [![Dependency Status](https://david-dm.org/ctavan/express-validator.svg)](https://david-dm.org/ctavan/express-validator)\r\n\r\nAn [express.js]( https://github.com/visionmedia/express ) middleware for\r\n[node-validator]( https://github.com/chriso/validator.js ).\r\n\r\n## Installation\r\n\r\n```\r\nnpm install express-validator\r\n```\r\n\r\n## Usage\r\n\r\n```javascript\r\nvar util = require('util'),\r\n    express = require('express'),\r\n    expressValidator = require('express-validator'),\r\n    app = express.createServer();\r\n\r\napp.use(express.bodyParser());\r\napp.use(expressValidator([options])); // this line must be immediately after express.bodyParser()!\r\n\r\napp.post('/:urlparam', function(req, res) {\r\n\r\n  // VALIDATION\r\n  // checkBody only checks req.body; none of the other req parameters\r\n  // Similarly checkParams only checks in req.params (URL params) and\r\n  // checkQuery only checks req.query (GET params).\r\n  req.checkBody('postparam', 'Invalid postparam').notEmpty().isInt();\r\n  req.checkParams('urlparam', 'Invalid urlparam').isAlpha();\r\n  req.checkQuery('getparam', 'Invalid getparam').isInt();\r\n\r\n  // OR assert can be used to check on all 3 types of params.\r\n  // req.assert('postparam', 'Invalid postparam').notEmpty().isInt();\r\n  // req.assert('urlparam', 'Invalid urlparam').isAlpha();\r\n  // req.assert('getparam', 'Invalid getparam').isInt();\r\n\r\n  // SANITIZATION\r\n  // as with validation these will only validate the corresponding\r\n  // request object\r\n  req.sanitizeBody('postparam').toBoolean();\r\n  req.sanitizeParams('urlparam').toBoolean();\r\n  req.sanitizeQuery('getparam').toBoolean();\r\n\r\n  // OR find the relevent param in all areas\r\n  req.sanitize('postparam').toBoolean();\r\n\r\n  var errors = req.validationErrors();\r\n  if (errors) {\r\n    res.send('There have been validation errors: ' + util.inspect(errors), 400);\r\n    return;\r\n  }\r\n  res.json({\r\n    urlparam: req.params.urlparam,\r\n    getparam: req.params.getparam,\r\n    postparam: req.params.postparam\r\n  });\r\n});\r\n\r\napp.listen(8888);\r\n```\r\n\r\nWhich will result in:\r\n\r\n```\r\n$ curl -d 'postparam=1' http://localhost:8888/test?getparam=1\r\n{\"urlparam\":\"test\",\"getparam\":\"1\",\"postparam\":true}\r\n\r\n$ curl -d 'postparam=1' http://localhost:8888/t1est?getparam=1\r\nThere have been validation errors: [\r\n  { param: 'urlparam', msg: 'Invalid urlparam', value: 't1est' } ]\r\n\r\n$ curl -d 'postparam=1' http://localhost:8888/t1est?getparam=1ab\r\nThere have been validation errors: [\r\n  { param: 'getparam', msg: 'Invalid getparam', value: '1ab' },\r\n  { param: 'urlparam', msg: 'Invalid urlparam', value: 't1est' } ]\r\n\r\n$ curl http://localhost:8888/test?getparam=1&postparam=1\r\nThere have been validation errors: [\r\n  { param: 'postparam', msg: 'Invalid postparam', value: undefined} ]\r\n```\r\n\r\n### Middleware Options\r\n####`errorFormatter`\r\n_function(param,msg,value)_\r\n\r\nThe `errorFormatter` option can be used to specify a function that can be used to format the objects that populate the error array that is returned in `req.validationErrors()`. It should return an `Object` that has `param`, `msg`, and `value` keys defined.\r\n\r\n```javascript\r\n// In this example, the formParam value is going to get morphed into form body format useful for printing.\r\napp.use(expressValidator({\r\n  errorFormatter: function(param, msg, value) {\r\n      var namespace = param.split('.')\r\n      , root    = namespace.shift()\r\n      , formParam = root;\r\n\r\n    while(namespace.length) {\r\n      formParam += '[' + namespace.shift() + ']';\r\n    }\r\n    return {\r\n      param : formParam,\r\n      msg   : msg,\r\n      value : value\r\n    };\r\n  }\r\n}));\r\n```\r\n\r\n####`customValidators`\r\n_{ \"validatorName\": function(value, [additional arguments]), ... }_\r\n\r\n\r\nThe `customValidators` option can be used to add additional validation methods as needed. This option should be an `Object` defining the validator names and associated validation functions.\r\n\r\nDefine your custom validators:\r\n\r\n```javascript\r\napp.use(expressValidator({\r\n customValidators: {\r\n    isArray: function(value) {\r\n        return Array.isArray(value);\r\n    },\r\n    gte: function(param, num) {\r\n        return param >= num;\r\n    }\r\n }\r\n}));\r\n```\r\nUse them with their validator name:\r\n```javascript\r\nreq.checkBody('users', 'Users must be an array').isArray();\r\nreq.checkQuery('time', 'Time must be an integer great than or equal to 5').isInt().gte(5)\r\n```\r\n####`customSanitizers`\r\n_{ \"sanitizerName\": function(value, [additional arguments]), ... }_\r\n\r\nThe `customSanitizers` option can be used to add additional sanitizers methods as needed. This option should be an `Object` defining the sanitizer names and associated functions.\r\n\r\nDefine your custom sanitizers:\r\n\r\n```javascript\r\napp.use(expressValidator({\r\n customSanitizers: {\r\n    toSanitizeSomehow: function(value) {\r\n        var newValue = value;//some operations\r\n        return newValue;\r\n    },\r\n }\r\n}));\r\n```\r\nUse them with their sanitizer name:\r\n```javascript\r\nreq.sanitize('address').toSanitizeSomehow();\r\n```\r\n\r\n## Validation\r\n\r\n#### req.check();\r\n```javascript\r\n   req.check('testparam', 'Error Message').notEmpty().isInt();\r\n   req.check('testparam.child', 'Error Message').isInt(); // find nested params\r\n   req.check(['testparam', 'child'], 'Error Message').isInt(); // find nested params\r\n```\r\n\r\nStarts the validation of the specifed parameter, will look for the parameter in `req` in the order `params`, `query`, `body`, then validate, you can use 'dot-notation' or an array to access nested values.\r\n\r\nIf a validator takes in params, you would call it like `req.assert('reqParam').contains('thisString');`.\r\n\r\nValidators are appended and can be chained. See [chriso/validator.js](https://github.com/chriso/validator.js) for available validators, or [add your own](#customvalidators).\r\n\r\n#### req.assert();\r\nAlias for [req.check()](#reqcheck).\r\n\r\n#### req.validate();\r\nAlias for [req.check()](#reqcheck).\r\n\r\n#### req.checkBody();\r\nSame as [req.check()](#reqcheck), but only looks in `req.body`.\r\n\r\n#### req.checkQuery();\r\nSame as [req.check()](#reqcheck), but only looks in `req.query`.\r\n\r\n#### req.checkParams();\r\nSame as [req.check()](#reqcheck), but only looks in `req.params`.\r\n\r\n#### req.checkHeaders();\r\nOnly checks `req.headers`. This method is not covered by the general `req.check()`.\r\n\r\n## Asynchronous Validation\r\n\r\nIf you need to perform asynchronous validation, for example checking a database if a username has been taken already, your custom validator can return a promise.\r\n\r\nYou **MUST** use `asyncValidationErrors` which returns a promise to check for errors, otherwise the validator promises won't be resolved.\r\n\r\n *`asyncValidationErrors` will also return any regular synchronous validation errors.*\r\n\r\n ```javascript\r\napp.use(expressValidator({\r\n  customValidators: {\r\n    isUsernameAvailable: function(username) {\r\n      return new Promise(function(resolve, reject) {\r\n        User.findOne({ username: username })\r\n        .then(function(user) {\r\n          if (user) {\r\n            resolve(user);\r\n          }\r\n          else {\r\n            reject(user);\r\n          }\r\n        })\r\n        .catch(function(error){\r\n          if (error) {\r\n            reject(error);\r\n          }\r\n        });\r\n      });\r\n    }\r\n  }\r\n}));\r\n\r\nreq.check('username', 'Username Taken').isUsernameAvailable();\r\n\r\nreq.asyncValidationErrors()\r\n.then(function() {\r\n// create user\r\n})\r\n.catch(function(errors) {\r\n  res.send(errors);\r\n});\r\n\r\n```\r\n## Validation by Schema\r\n\r\nAlternatively you can define all your validations at once using a simple schema. This also enables per-validator error messages.\r\nSchema validation will be used if you pass an object to any of the validator methods.\r\n\r\n```javascript\r\nreq.checkBody({\r\n 'email': {\r\n    notEmpty: true,\r\n    isEmail: {\r\n      errorMessage: 'Invalid Email'\r\n    }\r\n  },\r\n  'password': {\r\n    notEmpty: true,\r\n    matches: {\r\n      options: ['example', 'i'] // pass options to the validator with the options property as an array\r\n      // options: [/example/i] // matches also accepts the full expression in the first parameter\r\n    },\r\n    errorMessage: 'Invalid Password' // Error message for the parameter\r\n  },\r\n  'name.first': { //\r\n    optional: true, // won't validate if field is empty\r\n    isLength: {\r\n      options: [{ min: 2, max: 10 }],\r\n      errorMessage: 'Must be between 2 and 10 chars long' // Error message for the validator, takes precedent over parameter message\r\n    },\r\n    errorMessage: 'Invalid First Name'\r\n  }\r\n});\r\n```\r\n\r\nYou can also define a specific location to validate against in the schema by adding `in` parameter as shown below:\r\n\r\n```javascript\r\nreq.check({\r\n 'email': {\r\n    in: 'query',\r\n    notEmpty: true,\r\n    isEmail: {\r\n      errorMessage: 'Invalid Email'\r\n    }\r\n  }\r\n});\r\n```\r\n\r\nPlease remember that the `in` attribute will have always highest priority. This mean if you use `in: 'query'` then checkQuery() will be called inside even if you do `checkParams()` or `checkBody()`. For example, all of these calls will check query params for email param:\r\n\r\n\r\n```javascript\r\nvar schema = {\r\n 'email': {\r\n    in: 'query',\r\n    notEmpty: true,\r\n    isEmail: {\r\n      errorMessage: 'Invalid Email'\r\n    }\r\n  },\r\n  'password': {\r\n    notEmpty: true,\r\n    matches: {\r\n      options: ['example', 'i'] // pass options to the validator with the options property as an array\r\n      // options: [/example/i] // matches also accepts the full expression in the first parameter\r\n    },\r\n    errorMessage: 'Invalid Password' // Error message for the parameter\r\n  }\r\n};\r\n\r\nreq.check(schema);        // will check 'password' no matter where it is but 'email' in query params\r\nreq.checkQuery(schema);   // will check 'password' and 'email' in query params\r\nreq.checkBody(schema);    // will check 'password' in body but 'email' in query params\r\nreq.checkParams(schema);  // will check 'password' in path params but 'email' in query params\r\n```\r\n\r\nCurrently supported location are `'body', 'params', 'query'`. If you provide a location parameter that is not supported, the validation process for current parameter will be skipped.\r\n\r\n## Validation errors\r\n\r\nYou have two choices on how to get the validation errors:\r\n\r\n```javascript\r\nreq.assert('email', 'required').notEmpty();\r\nreq.assert('email', 'valid email required').isEmail();\r\nreq.assert('password', '6 to 20 characters required').len(6, 20);\r\n\r\nvar errors = req.validationErrors(); // Or req.asyncValidationErrors();\r\nvar mappedErrors = req.validationErrors(true); // Or req.asyncValidationErrors(true);\r\n```\r\n\r\nerrors:\r\n\r\n```javascript\r\n[\r\n  {param: \"email\", msg: \"required\", value: \"<received input>\"},\r\n  {param: \"email\", msg: \"valid email required\", value: \"<received input>\"},\r\n  {param: \"password\", msg: \"6 to 20 characters required\", value: \"<received input>\"}\r\n]\r\n```\r\n\r\nmappedErrors:\r\n\r\n```javascript\r\n{\r\n  email: {\r\n    param: \"email\",\r\n    msg: \"valid email required\",\r\n    value: \"<received input>\"\r\n  },\r\n  password: {\r\n    param: \"password\",\r\n    msg: \"6 to 20 characters required\",\r\n    value: \"<received input>\"\r\n  }\r\n}\r\n```\r\n*Note: Using mappedErrors will only provide the last error per param in the chain of validation errors.*\r\n\r\n### String formatting for error messages\r\n\r\nError messages can be customized to include both the value provided by the user, as well as the value of any parameters passed to the validation function, using a standard string replacement format:\r\n\r\n`%0` is replaced with user input  \r\n`%1` is replaced with the first parameter to the validator  \r\n`%2` is replaced with the second parameter to the validator  \r\netc...\r\n\r\nExample:\r\n```javascript\r\nreq.assert('number', '%0 is not an integer').isInt();\r\nreq.assert('number', '%0 is not divisible by %1').isDivisibleBy(5);\r\n```\r\n\r\n*Note:* string replacement does **not** work with the `.withMessage()` syntax. If you'd like to have per-validator error messages with string formatting, please use the [Validation by Schema](#validation-by-schema) method instead.\r\n\r\n### Per-validation messages\r\n\r\nYou can provide an error message for a single validation with `.withMessage()`. This can be chained with the rest of your validation, and if you don't use it for one of the validations then it will fall back to the default.\r\n\r\n```javascript\r\nreq.assert('email', 'Invalid email')\r\n    .notEmpty().withMessage('Email is required')\r\n    .isEmail();\r\nvar errors = req.validationErrors();\r\n```\r\nerrors:\r\n\r\n```javascript\r\n[\r\n  {param: 'email', msg: 'Email is required', value: '<received input>'}\r\n  {param: 'email', msg: 'Invalid Email', value: '<received input>'}\r\n]\r\n```\r\n\r\n## Optional input\r\n\r\nYou can use the `optional()` method to skip validation. By default, it only skips validation if the key does not exist on the request object. If you want to skip validation based on the property being falsy (null, undefined, etc), you can pass in `{ checkFalsy: true }`.\r\n\r\n```javascript\r\nreq.checkBody('email').optional().isEmail();\r\n//if there is no error, req.body.email is either undefined or a valid mail.\r\n```\r\n\r\n## Sanitizer\r\n\r\n#### req.sanitize();\r\n```javascript\r\n\r\nreq.body.comment = 'a <span>comment</span>';\r\nreq.body.username = '   a user    ';\r\n\r\nreq.sanitize('comment').escape(); // returns 'a &lt;span&gt;comment&lt;/span&gt;'\r\nreq.sanitize('username').trim(); // returns 'a user'\r\n\r\nconsole.log(req.body.comment); // 'a &lt;span&gt;comment&lt;/span&gt;'\r\nconsole.log(req.body.username); // 'a user'\r\n\r\n```\r\n\r\nSanitizes the specified parameter (using 'dot-notation' or array), the parameter will be updated to the sanitized result. Cannot be chained, and will return the result. See [chriso/validator.js](https://github.com/chriso/validator.js) for available sanitizers, or [add your own](#customsanitizers).\r\n\r\nIf a sanitizer takes in params, you would call it like `req.sanitize('reqParam').whitelist(['a', 'b', 'c']);`.\r\n\r\nIf the parameter is present in multiple places with the same name e.g. `req.params.comment` & `req.query.comment`, they will all be sanitized.\r\n\r\n#### req.filter();\r\nAlias for [req.sanitize()](#reqsanitize).\r\n\r\n#### req.sanitizeBody();\r\nSame as [req.sanitize()](#reqsanitize), but only looks in `req.body`.\r\n\r\n#### req.sanitizeQuery();\r\nSame as [req.sanitize()](#reqsanitize), but only looks in `req.query`.\r\n\r\n#### req.sanitizeParams();\r\nSame as [req.sanitize()](#reqsanitize), but only looks in `req.params`.\r\n\r\n#### req.sanitizeHeaders();\r\nOnly sanitizes `req.headers`. This method is not covered by the general `req.sanitize()`.\r\n\r\n### Regex routes\r\n\r\nExpress allows you to define regex routes like:\r\n\r\n```javascript\r\napp.get(/\\/test(\\d+)/, function() {});\r\n```\r\n\r\nYou can validate the extracted matches like this:\r\n\r\n```javascript\r\nreq.assert(0, 'Not a three-digit integer.').len(3, 3).isInt();\r\n```\r\n\r\n## Changelog\r\n\r\nSee [CHANGELOG.md](CHANGELOG.md)\r\n\r\n## Contributors\r\n\r\n- Christoph Tavan <dev@tavan.de> - Wrap the gist in an npm package\r\n- @orfaust - Add `validationErrors()` and nested field support\r\n- @zero21xxx - Added `checkBody` function\r\n\r\n## License\r\n\r\nCopyright (c) 2010 Chris O'Hara <cohara87@gmail.com>, MIT License\r\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/ctavan/express-validator/issues"
  },
  "_id": "express-validator@2.20.10",
  "dist": {
    "shasum": "7c34e533f9018df3567af1eb6341f092b8febbeb"
  },
  "_from": "express-validator@",
  "_resolved": "https://registry.npmjs.org/express-validator/-/express-validator-2.20.10.tgz"
}
